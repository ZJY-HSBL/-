## 第1章 算法

### 1.1 算法是什么

#### 1.2.1 算法定义

算法（algorithm）是在有限时间内解决特定问题的一组指令或步骤。

特性：

- 问题是明确的，包含清晰的输入和输出定义。

- 具有可行性，能够在有限步骤、时间和内存空间下完成。

- 各步骤都有确定的含义，在相同的输入和运行条件下，输出始终相同。

#### 1.2.1 算法定义

数据结构（data structure）是组织和存储数据的方式，涵盖数据内容、数据之间关系和数据操作方法。

设计目标：

- 空间占用尽量少，以节省计算机内存。

- 数据操作尽可能快速，涵盖数据访问、添加、删除、更新等。

- 提供简洁的数据表示和逻辑信息，以便算法高效运行。

数据结构设计是一个充满权衡的过程。

若想在某方面取得提升，则需在另一方面作出妥协。

例：

- 链表相较于数组，在数据添加和删除操作上更加便捷，但牺牲了数据访问速度。

- 图相较于链表，提供了更丰富的逻辑信息，但需要占用更大的内存空间。

#### 1.2.3   数据结构与算法的关系

数据结构与算法高度相关、紧密结合，具体表现在以下三个方面：

- 数据结构是算法的基石。数据结构为算法提供了结构化存储的数据，以及操作数据的方法。

- 算法是数据结构发挥作用的舞台。数据结构本身仅存储数据信息，结合算法才能解决特定问题。

- 算法通常可以基于不同的数据结构实现，但执行效率可能相差很大，选择合适的数据结构是关键。

## 第2章 复杂度分析

### 2.1 算法效率评估

在算法设计中，需先后追求两个层面的目标。

1. 找到问题解法：算法需要在规定的输入范围内可靠地求得问题的正确解。

2. 寻求最优解法：同一个问题可能存在多种解法，找到尽可能高效的算法。

也就是说，在能够解决问题的前提下，算法效率已成为衡量算法优劣的主要评价指标，包括以下两个维度：

- 时间效率：算法运行时间的长短。

- 空间效率：算法占用内存空间的大小。

简而言之，目标是设计“既快又省”的数据结构与算法。而有效地评估算法效率至关重要，因为只有这样，才可将各种算法进行对比，进而指导算法设计与优化过程。

效率评估方法主要分为两种：实际测试、理论估算。

#### 2.1.1 实际测试

假设现在有算法 A 和算法 B ，它们都能解决同一问题。

现在需要对比这两个算法的效率。

最直接的方法是找一台计算机，运行这两个算法，并监控记录它们的运行时间和内存占用情况。

这种评估方式能够反映真实情况，但也存在较大的局限性。

- 一方面，难以排除测试环境的干扰因素。硬件配置会影响算法的性能表现。比如一个算法的并行度较高，其就更适合在多核 CPU 上运行，一个算法的内存操作密集，其在高性能内存上的表现就会更好。也就是说，算法在不同的机器上的测试结果可能是不一致的。这意味着需要在各种机器上进行测试，统计平均效率，而这是不现实的。

- 另一方面，展开完整测试非常耗费资源。随着输入数据量的变化，算法会表现出不同的效率。例如，在输入数据量较小时，算法 A 的运行时间比算法 B 短；而在输入数据量较大时，测试结果可能恰恰相反。因此，为了得到有说服力的结论，需要测试各种规模的输入数据，而这需要耗费大量的计算资源。

#### 2.1.2 理论估算

实际测试具有较大的局限性，因而可以考虑仅通过一些计算来评估算法的效率。

这种估算方法被称为渐近复杂度分析（asymptotic complexity analysis），简称复杂度分析。

复杂度分析能够体现算法运行所需的时间和空间资源与输入数据大小之间的关系。

它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势。

- “时间和空间资源”分别对应时间复杂度（time complexity）和空间复杂度（space complexity）。

- “随着输入数据大小的增加”意味着复杂度反映了算法运行效率与输入数据体量之间的关系。

- “时间和空间的增长趋势”表示复杂度分析关注的不是运行时间或占用空间的具体值，而是时间或空间增长的“快慢”。

复杂度分析克服了实际测试方法的弊端。

体现：

- 无需实际运行代码，更加绿色节能。

- 独立于测试环境，分析结果适用于所有运行平台。

- 可以体现不同数据量下的算法效率，尤其是在大数据量下的算法性能。

### 2.2 迭代与递归

算法中，重复执行某个任务很常见。

其与复杂度分析息息相关。

通过两种基本的程序控制结构：迭代、递归，来实现重复执行任务。

#### 2.2.1 迭代

迭代（iteration）是一种重复执行某个任务的控制结构。

在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足。

##### 1.for循环

for 循环是最常见的迭代形式之一，适合在预先知道迭代次数时使用。

以下函数基于 for 循环实现了求和 1+2+3+......+n ，求和结果使用变量 res 记录。

~~~ c
/* for 循环 */
int forLoop(int n) {
    int res = 0;
    // 循环求和 1, 2, ..., n-1, n
    for (int i = 1; i <= n; i++) {
        res += i;
    }
    return res;
}
~~~

此求和函数的操作数量与输入数据大小n成正比，或者说成”线性关系”。

实际上，时间复杂度描述的就是这个“线性关系”。

##### 2.while循环

与 for 循环类似，while 循环也是一种实现迭代的方法。

在 while 循环中，程序每轮都会先检查条件，如果条件为真，则继续执行，否则就结束循环。

下面用 while 循环来实现求和1+2+3+......+n。

~~~ c
/* while 循环 */
int whileLoop(int n) {
    int res = 0;
    int i = 1; // 初始化条件变量
    // 循环求和 1, 2, ..., n-1, n
    while (i <= n) {
        res += i;
        i++; // 更新条件变量
    }
    return res;
}
~~~

while 循环比 for 循环的自由度更高。

在 while 循环中，可以自由地设计条件变量的初始化和更新步骤。

例如在以下代码中，条件变量i每轮进行两次更新，此情况就不太方便用 for 循环实现。

~~~ c
/* while 循环（两次更新） */
int whileLoopII(int n) {
    int res = 0;
    int i = 1; // 初始化条件变量
    // 循环求和 1, 4, 10, ...
    while (i <= n) {
        res += i;
        // 更新条件变量
        i++;
        i *= 2;
    }
    return res;
}
~~~
总的来说，for 循环的代码更加紧凑，while 循环更加灵活，两者都可以实现迭代结构。

选择使用哪一个应该根据特定问题的需求来决定。

##### 3.嵌套循环

可以在一个循环结构内嵌套另一个循环结构，下面以 for 循环为例。

~~~ c
/* 双层 for 循环 */
char *nestedForLoop(int n) {
    // n * n 为对应点数量，"(i, j), " 对应字符串长最大为 6+10*2，加上最后一个空字符 \0 的额外空间
    int size = n * n * 26 + 1;
    char *res = malloc(size * sizeof(char));
    // 循环 i = 1, 2, ..., n-1, n
    for (int i = 1; i <= n; i++) {
        // 循环 j = 1, 2, ..., n-1, n
        for (int j = 1; j <= n; j++) {
            char tmp[26];
            snprintf(tmp, sizeof(tmp), "(%d, %d), ", i, j);
            strncat(res, tmp, size - strlen(res) - 1);
        }
    }
    return res;
}
~~~

在这种情况下，函数的操作数量与n^2成正比，或者说算法运行时间和输入数据大小n成“平方关系”。

可以继续添加嵌套循环，每一次嵌套都是一次“升维”，将会使时间复杂度提高至“立方关系”、“四次方关系”，以此类推。

#### 2.2.2 递归

递归（recursion）是一种算法策略，通过函数调用自身来解决问题。

主要包含两个阶段。

1. 递：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。

2. 归：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。

而从实现的角度看，递归代码主要包含三个要素。

1. 终止条件：用于决定什么时候由“递”转“归”。

2. 递归调用：对应“递”，函数调用自身，通常输入更小或更简化的参数。

3. 返回结果：对应“归”，将当前递归层级的结果返回至上一层。

观察以下代码，只需调用函数 recur(n) ，就可以完成1+2+3+……+n的计算。 

~~~ c
/* 递归 */
int recur(int n) {
    // 终止条件
    if (n == 1)
        return 1;
    // 递：递归调用
    int res = recur(n - 1);
    // 归：返回结果
    return n + res;
}
~~~

虽然从计算角度看，迭代与递归可以得到相同的结果，但其代表了两种完全不同的思考和解决问题的范式。

- 迭代：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。

- 递归：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。

以上述求和函数为例，设问题f(n)=1+2+3+……+n。 
 。

- 迭代：在循环中模拟求和过程，从1遍历到n，每轮执行求和操作，即可求得f(n)。

- 递归：将问题分解为子问题f(n)=n+f(n-1)，不断（递归地）分解下去，直至基本情况f(1)=1时终止。

##### 1.调用栈

递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。

将导致两方面的结果：

- 函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，递归通常比迭代更加耗费内存空间。

- 递归调用函数会产生额外的开销。因此递归通常比循环的时间效率更低。

在触发终止条件前，同时存在n个未返回的递归函数，递归深度为n。

在实际中，编程语言允许的递归深度通常是有限的，过深的递归可能导致栈溢出错误。

##### 2.尾递归

如果函数在返回前的最后一步才进行递归调用，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。

这种情况被称为尾递归（tail recursion）。

- 普通递归：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。

- 尾递归：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。

以计算1+2+3+……+n为例，我们可以将结果变量 res 设为函数参数，从而实现尾递归。

~~~c
/* 尾递归 */
int tailRecur(int n, int res) {
    // 终止条件
    if (n == 0)
        return res;
    // 尾递归调用
    return tailRecur(n - 1, res + n);
}
~~~

对比普通递归和尾递归，两者的求和操作的执行点是不同的。

- 普通递归：求和操作是在“归”的过程中执行的，每层返回后都要再执行一次求和操作。

- 尾递归：求和操作是在“递”的过程中执行的，“归”的过程只需层层返回。

##### 3.递归树

当处理与“分治”相关的算法问题时，递归往往比迭代的思路更加直观、代码更加易读。

以“斐波那契数列”为例。

给定一个斐波那契数列0、1、1、2、3、5、8、13、……，求该数列的第n个数字。

设斐波那契数列的第n个数字为f(n)，易得两个结论。

数列的前两个数字为f(1)=0和f(2)=1。 

数列中的每个数字是前两个数字的和，即f(n)=f(n-1)+f(n-2)。

按照递推关系进行递归调用，将前两个数字作为终止条件，便可写出递归代码。

调用 fib(n) 即可得到斐波那契数列的第n个数字。

~~~c
/* 斐波那契数列：递归 */
int fib(int n) {
    // 终止条件 f(1) = 0, f(2) = 1
    if (n == 1 || n == 2)
        return n - 1;
    // 递归调用 f(n) = f(n-1) + f(n-2)
    int res = fib(n - 1) + fib(n - 2);
    // 返回结果 f(n)
    return res;
}
~~~

在函数内递归调用了两个函数，这意味着从一个调用产生了两个调用分支。

不断递归调用下去，最终将产生一棵层数为n的递归树（recursion tree）。

从本质上看，递归体现了“将问题分解为更小子问题”的思维范式，这种分治策略至关重要。

- 从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略直接或间接地应用了这种思维方式。

- 从数据结构角度看，递归天然适合处理链表、树和图的相关问题，因为它们非常适合用分治思想进行分析。

#### 2.2.3 两者对比

迭代和递归在实现、性能和适用性上有所不同。

**迭代与递归特点对比**

|      | 迭代 |   递归   |
| ---- | :--: | ---- |
|  实现方式    | 循环结构 | 函数调用自身 |
|  时间效率    | 效率通常较高，无函数调用开销 | 每次函数调用都会产生开销 |
|  内存使用  | 通常使用固定大小的内存空间 | 累积函数调用可能使用大量的栈帧空间 |
| 适用问题 | 适用于简单循环任务，代码直观、可读性好 | 适用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰 |

那么，迭代和递归具有什么内在联系呢？

以上述递归函数为例，求和操作在递归的“归”阶段进行。

这意味着最初被调用的函数实际上是最后完成其求和操作的，这种工作机制与栈的“先入后出”原则异曲同工。

事实上，“调用栈”和“栈帧空间”这类递归术语已经暗示了递归与栈之间的密切关系。

- 递：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于存储函数的局部变量、参数、返回地址等数据。

- 归：当函数完成执行并返回时，对应的栈帧会被从“调用栈”上移除，恢复之前函数的执行环境。

因此，可以使用一个显式的栈来模拟调用栈的行为，从而将递归转化为迭代形式。

~~~ c
/* 使用迭代模拟递归 */
int forLoopRecur(int n) {
    int stack[1000]; // 借助一个大数组来模拟栈
    int top = -1;    // 栈顶索引
    int res = 0;
    // 递：递归调用
    for (int i = n; i > 0; i--) {
        // 通过“入栈操作”模拟“递”
        stack[1 + top++] = i;
    }
    // 归：返回结果
    while (top >= 0) {
        // 通过“出栈操作”模拟“归”
        res += stack[top--];
    }
    // res = 1+2+3+...+n
    return res;
}
~~~

当递归转化为迭代后，代码变得更加复杂了。

尽管迭代和递归在很多情况下可以互相转化，但不一定值得这样做。

原因：

- 转化后的代码可能更加难以理解，可读性更差。

- 对于某些复杂问题，模拟系统调用栈的行为可能非常困难。

总之，选择迭代还是递归取决于特定问题的性质。

在编程实践中，权衡两者的优劣并根据情境选择合适的方法至关重要。

## 第4章 数组与链表

### 4.1 数组

数组（arry）是一种线性数据结构，其将相同类型的元素存储在连续的内存空间中。

元素在数组中的位置称为该元素的索引（index）。

#### 4.1.1 数组常用操作

##### 1.初始化数组

根据需求选优数组的两种初始化方式：无初始值、给定初始值。

在未指定初始值的情况下，大多数编程语言会将数组元素初始化为0。

##### 2.访问元素

数组元素存储在连续的内存空间中。

索引本质上是内存地址的偏移量。

在数组中访问元素非常高效，可在O(1)时间内随机访问数组中的任意一个元素。

~~~c
/* 随机访问元素 */
int randomAccess(int *nums, int size) {
    // 在区间 [0, size) 中随机抽取一个数字
    int randomIndex = rand() % size;
    // 获取并返回随机元素
    int randomNum = nums[randomIndex];
    return randomNum;
}
~~~

##### 3.插入元素

若想在数组中间插入一个元素，则需要将该元素之后的所有元素都向后移动一位，之后再把元素赋值给该索引。

若数组长度是固定的，则在插入一个元素后必定导致该数组尾部元素“丢失”。

~~~c
/* 在数组的索引 index 处插入元素 num */
void insert(int *nums, int size, int num, int index) {
    // 把索引 index 以及之后的所有元素向后移动一位
    for (int i = size - 1; i > index; i--) {
        nums[i] = nums[i - 1];
    }
    // 将 num 赋给 index 处的元素
    nums[index] = num;
}
~~~

##### 5.删除元素

若想删除索引i处的元素，则需要将索引i之后的所有元素都向后移动一位。

~~~c
/* 删除索引 index 处的元素 */
// 注意：stdio.h 占用了 remove 关键词
void removeItem(int *nums, int size, int index) {
    // 把索引 index 之后的所有元素向前移动一位
    for (int i = index; i < size - 1; i++) {
        nums[i] = nums[i + 1];
    }
}
~~~

数组的插入与删除有以下缺点：

- 时间复杂度：数组的插入和删除的平均时间复杂度均为O(n)，其中n为数组长度。
- 丢失元素：由于数组的长度不可变，因此在插入数组后，超出该数组长度范围的元素会丢失。
- 内存浪费：当初始化一个比较长的数组时，只用前面一部分，在插入数据后，丢失的末尾元素都是“无意义”的，但这样做会造成内存空间浪费。

##### 5.遍历数组

在大多数编程语言中，不仅可以通过索引便利数组，也可以直接遍历获取数组中的每个元素。

~~~c
/* 遍历数组 */
void traverse(int *nums, int size) {
    int count = 0;
    // 通过索引遍历数组
    for (int i = 0; i < size; i++) {
        count += nums[i];
    }
}
~~~

##### 6.查找元素

在数组中查找指定元素需要遍历数组，每轮判断元素值是否匹配，若匹配则输出队形索引。

因为数组是线性数据结构，因而上述查找操作被称为“线性查找”。

~~~c
/* 在数组中查找指定元素 */
int find(int *nums, int size, int target) {
    for (int i = 0; i < size; i++) {
        if (nums[i] == target)
            return i;
    }
    return -1;
}
~~~

##### 7.扩容数组

复杂系统环境中，程序难以保证数组之后的内存空间是可用的，从而无法安全的扩展数组容量。

因为在大多数编程语言中，数组长度是不可变的。

若想扩展数组，则需要重新建立一个更大的数组，然后把原数组元素一次复制到新数组。

此操作时间复杂度为O(n)，在数组很大的情况下非常耗时。

~~~c
/* 扩展数组长度 */
int *extend(int *nums, int size, int enlarge) {
    // 初始化一个扩展长度后的数组
    int *res = (int *)malloc(sizeof(int) * (size + enlarge));
    // 将原数组中的所有元素复制到新数组
    for (int i = 0; i < size; i++) {
        res[i] = nums[i];
    }
    // 初始化扩展后的空间
    for (int i = size; i < size + enlarge; i++) {
        res[i] = 0;
    }
    // 返回扩展后的新数组
    return res;
}
~~~

#### 4.1.2 数组常用操作

数组存储在连续的内存空间内，且元素类型相同。

这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。

- 空间效率高：数组为数据分配了连续的内存块，无须额外的结构开销。
- 支持随机访问：数组允许在O(1)时间内访问任何元素。
- 缓存局部性：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。

连续空间存储存在以下局限性：

- 插入与删除效率低：当数组中元素较多时，插入与删除操作需要移动大量的元素。
- 长度不可变：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组中，开销很大。
- 空间浪费：若数组分配的大小超过实际所需，那么多余空间便被浪费了。

#### 4.1.3数组类型应用

数组是一种基础且常见的数据结构，既频繁应用在各类算法之中，也可用于实现各种复杂数据结构。

- **随机访问**：若想随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现随机抽样。
- 排序和搜索：数组是排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行。
- 查找表：当需要快速查找一个元素或其对应关系时，可以使用数组作为查找表。若想实现字符到 ASCII 码的映射，则可以将字符的 ASCII 码值作为索引，对应的元素存放在数组中的对应位置。
- 机器学习：神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。
- 数据结构实现：数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，图的邻接矩阵表示实际上是一个二维数组。
