# 代码随想录

## 1.数组理论基础

数组是存放在连续内存空间上相同类型数据的集合。

注意：

- 数字下标都是从0开始的
- 数组内存空间的地址是连续的

因为数组在内存空间里是连续的，所以在删除或者添加元素的时候，就需要移动其他元素的地址。

数组元素不可删除，只可以进行覆盖。

## 2.二分查找

二分法前提条件：

- 数组必须为有序的
- 没有重复元素

### 两种情况

#### target定义在[left,right]中

注意：
1. while(left<=right): target定义在[left,right]中，left=right是有意义的，因此使用<=。
2. right=middle-1: 当前nums[middle]一定不是target，因此接下来查找的左区间的结束下标位置是middle-1。

代码：

```c
int search(int*nums,int mumsSize,int target)
{
    int left=0;
    int right=numsSize-1;
    int middle=0;
    //若left<=right,说明区间中元素不为0
    while(left<=right)
    {
        //更新查找下标middle的值
        middle=(left+right)/2;
        //此时target可能在[left,middle-1]中
        if(nums[middle]>target)
        {
            right=middle-1;
        }
        //此时target可能在[middle+1,right]中
        else if(nums[middle]<target)
        {
            left=middle+1;
        }
        //当前下标元素等于target值时，返回middle
        else if(nums[middle]==target)
        {
            return middle;
        }
    }
    //若未找到target元素，返回-1
    return -1;
}
```

- 时间复杂度：O(log n)
- 空间复杂度：O(1)

#### targrt定义在[left,right)中

注意：
1. while(left<right): 在[left,right)中，left不可能等于right。
2. right=middle: 当前nums[middle]不等于target，便从左区间开始寻找。且区间为[  ,  )(左闭右开)，可直接将right更新为middle，因为下一个查找区间不会再去比较nums[middle]。

```c
int search(int* nums, int numsSize, int target)
{
    int length = numsSize;
    int left = 0;
    int right = length;	//定义target在左闭右开的区间里，即：[left,right)
    int middle = 0;
    // [left,right)，left不可能等于right
    while(left<right)
    {  
        int middle=left + (right-left)/2;
        if(nums[middle]<target)
        {
            //target位于(middle,right) 中为保证集合区间的左闭右开性，可等价为[middle+1,right)
            left = middle + 1;
        }
        else if(nums[middle]>target)
        {
            //target位于[left,middle)中
            right=middle;
        }
        else
        {	//nums[middle]==target ，找到目标值target
            return middle;
        }
    }
    //未找到目标值，返回-1
    return -1;
}
```

- 时间复杂度：O(log n)
- 空间复杂度：O(1)

### 例题:

#### 力扣704：二分查找

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
答案：
```c
int search(int* nums, int numsSize, int target)
{
    int left=0;
    int right=numsSize-1;
    while(left<=right)
    {
        int middle=left+(left+right)/2;
        if(nums[middle]>target)
        {
            right=middle-1;
        }
        else if(nums[middle]<target)
        {
            left=middle+1;
        }
        else
        {
            return middle;
        }
    }
    return -1;
}
```
#### 力扣35：搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
答案：
```c
int searchInsert(int*nums,int numsSize,int target)
{
    int left=0;
    int right=numsSize-1;
    while(left<=right)
    {
        int middle=left+(left+right)/2;
        if(nums[middle]>target)
        {
            left=middle+1;
        }
        else if(nums[middle]<target)
        {
            right=middle-1;
        }
        else
        {
            return middle;
        }
    }
    return left;
}
```
#### 力扣34：在排序数组中查找元素的第一个和最后一个位置

给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。